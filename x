typedef struct vector_int vector_int; struct vector_int { begin_func* _begin; end_func* _end; size_t size; size_t capacity; int* arr; }; void vector_next_func_int(iterator* iter) { iter->current = (int*)iter->current + 1; } int* vector_get_func_int(iterator* iter) { return iter->current; } iterator vector_begin_int(void* current) { return (iterator){ ((vector_int*)current)->arr, vector_next_func_int, vector_get_func_int, }; } iterator vector_end_int(void* current) { return (iterator){ ((vector_int*)(current))->arr + ((vector_int*)(current))->size, vector_next_func_int, vector_get_func_int, }; } vector init_vector_int(size_t capacity) { int* arr = malloc(sizeof(int) * capacity); (__builtin_expect(!(arr != ((void *)0)), 0) ? __assert_rtn(__func__, "vector.c", 82, "arr != NULL") : (void)0); return (vector_int){ vector_begin_int, vector_end_int, 0, capacity, arr, }; } void realloc_vector_int(vector_int* vec, size_t new_capacity) { vec->capacity = new_capacity; int* arr = malloc(sizeof(int) * new_capacity); __builtin___memcpy_chk (arr, vec->arr, new_capacity, __builtin_object_size (arr, 0)); free(vec->arr); vec->arr = arr; } void push_back_int(vector_int* vec, int value) { (__builtin_expect(!(vec != ((void *)0)), 0) ? __assert_rtn(__func__, "vector.c", 82, "vec != NULL") : (void)0); if (vec->size == vec->capacity) { realloc_vector_int(vec, vec->capacity * 2); } vec->arr[vec->size++] = value; } int pop_back_int(vector_int* vec) { (__builtin_expect(!(vec != ((void *)0)), 0) ? __assert_rtn(__func__, "vector.c", 82, "vec != NULL") : (void)0); return vec->arr[--vec->size]; } int get_int(const vector_int* v, size_t index) { (__builtin_expect(!(v != ((void *)0)), 0) ? __assert_rtn(__func__, "vector.c", 82, "v != NULL") : (void)0); (__builtin_expect(!(index < v->size), 0) ? __assert_rtn(__func__, "vector.c", 82, "index < v->size") : (void)0); return v->arr[index]; };
